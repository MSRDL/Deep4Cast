import numpy as np
import pandas as pd

from AnomalyDetection import detect_anomalies

def label_anomaly_windows(label):
    """
    :param label (type: panda series): input labels 1/0 for each point
    :return (type: list): set of intervals of anomaly (start time, end time)
    """
    labels = label.values
    timestamps = label.index
    labeled_anomaly_window = []
    for i in range(1, len(label)):
        if labels[i] == 1 and labels[i-1] == 0:
            start = timestamps[i]
        elif labels[i-1] == 1 and labels[i] == 0:
            end = timestamps[i-1]
            labeled_anomaly_window.append((start, end))
  
    return labeled_anomaly_window

def calculate_IOU(anomalies, label):
    """
    :param anomalies (panda dataframe): anomaly windows generated by the algorithm
    :param label (type: panda series): input labels 1/0 for each point
    :return iou (type: list): intersection over union if the anomaly windows overlap with actual labels else 0
    :return anomaly_region (type: list): list of labels associated with each anomaly window since there could be multiple
    """
    label_window = label_anomaly_windows(label)
    from datetime import datetime
    iou = []
    anomaly_region = []
    def stt(s): return datetime.strptime(s, "%Y-%m-%d %H:%M:%S")
    def t_max(t1, t2): return t1 if t1 > t2 else t2
    def t_min(t1, t2): return t1 if t1 < t2 else t2
        
    
    for i in range(len(anomalies)):
        iou_i = 0
        region = []
        start = stt(anomalies.start[i])
        end = stt(anomalies.end[i])
        for j in range(len(label_window)):

            if start <= label_window[j][0] and end >= label_window[j][0]:
                overlap = 1 + (t_min(label_window[j][1], end) - label_window[j][0]).total_seconds()/60 
                union   = 1 + (t_max(label_window[j][1], end)- start).total_seconds()/60 
                iou_i += (float(overlap)/union)
                region.append(j)

            elif start >= label_window[j][0] and end <= label_window[j][1]:
                overlap = 1 + (end - start).total_seconds()/60 
                union   = 1 + (label_window[j][1]- label_window[j][0]).total_seconds()/60 
                iou_i += (float(overlap)/union)
                region.append(j)
                
            elif start <= label_window[j][1] and end >= label_window[j][1]:
                overlap = 1 + (label_window[j][1] - start).total_seconds()/60 
                union   = 1 + (end - label_window[j][0]).total_seconds()/60 
                iou_i += (float(overlap)/union)
                region.append(j)
                
        anomaly_region.append(region)
        iou.append(iou_i)  
    
    return iou, anomaly_region

def AP_score(anomalies, label, iou_threshold):
    """
    :param anomalies (panda dataframe): anomaly windows generated by the algorithm
    :param label (type: panda series): input labels 1/0 for each point
    :param iou_threshold (type: float): threshold above which regions are considered correct detection
    :return (type: float) : AP_score (average precision)
    """
    labeled_data = label_anomaly_windows(label)
    iou, anomaly_region = calculate_IOU(anomalies, label)
    
    precision = []
    recall = []
    for i in range(1, len(iou)):
        iou_i = iou[:i]
        region = []
        tp, fp, fn = 0,0,0
        for j in range(len(iou_i)):
            if iou_i[j] > iou_threshold:
                tp += 1
                for window in anomaly_region[j]:
                    if window not in region:
                        region.append(window)
        fp = len(iou_i) - tp
                
        precision.append(float(tp)/ (tp + fp))
        recall.append(len(region)/ len(labeled_data))
    
    #Recall values for calculating average precision
    recall_interp = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
    recall_interp = recall_interp[::-1]
    recall = recall[::-1]
    precision = precision[::-1]
    precision_interp = []
    for val in recall_interp:
        k = 0
        p = 0
        while k < len(recall) and recall[k] >= val :
            p = precision[k] if precision[k] >= p else p
            k += 1
            
        precision_interp.append(p)
    return np.mean(precision_interp)


def evaluate(data, labels, lag):
    """
    :param data (type: panda series): input time series data
    :param labels (type: panda series): input labels 1/0 for each point
    :param lag (type: int): lag time
    :return (type: float): mean average precision score over given intersection over union (IoU) thresholds 
    """
    anomalies, _ = detect_anomalies(data, lag, num_anomalies=len(data)/lag, visualize=False)
    #Various IoU thresholds for calculating mean of average precision over each IoU threshold
    iou_thresholds = [0.0, 0.1, 0.2, 0.3]
    mean = 0
    for i in range(len(iou_thresholds)):
        mean += AP_score(anomalies, labels, iou_thresholds[i])
    return float(mean)/ len(iou_thresholds)





















